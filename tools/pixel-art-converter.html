<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>ドット絵コンバーター</title>
<style>
  :root {
    --bg: #1a1a2a;
    --panel: #0f1424;
    --accent: #F5A623;
    --muted: #777;
    --text: #eee;
  }
  * { box-sizing: border-box; }
  body { margin:0; background: var(--bg); color: var(--text); font-family: monospace; }
  h1 { margin: 20px 0 8px; font-size: 24px; color: var(--accent); }
  .wrap { max-width: 1100px; margin: 0 auto; padding: 16px; }
  .grid { display: grid; grid-template-columns: 1fr 1fr; gap: 16px; }
  .panel { background: var(--panel); border: 1px solid rgba(245,166,35,0.3); border-radius: 10px; padding: 14px; }
  .row { display: flex; gap: 10px; align-items: center; flex-wrap: wrap; }
  .row > label { min-width: 120px; color: #ddd; }
  .drop {
    border: 2px dashed rgba(245,166,35,0.5);
    border-radius: 10px; padding: 24px; text-align: center; background: rgba(255,255,255,0.02);
  }
  input[type="file"] { display: none; }
  .drop.drag { border-color: var(--accent); background: rgba(245,166,35,0.08); }
  button { background: var(--accent); color: #000; border: none; padding: 8px 16px; border-radius: 6px; cursor: pointer; font-weight: bold; }
  button.secondary { background: #555; color: #eee; }
  select, input[type="number"], input[type="color"], input[type="range"] {
    background: #0b0f1c; color: #eee; border: 1px solid #333; padding: 6px 8px; border-radius: 6px;
  }
  .canvas-wrap { background: #0b0f1c; padding: 8px; border-radius: 8px; border: 1px solid #222; }
  canvas { width: 100%; height: auto; image-rendering: pixelated; background: transparent; display: block; }
  .checker {
    background-image:
      linear-gradient(45deg, #444 25%, transparent 25%),
      linear-gradient(-45deg, #444 25%, transparent 25%),
      linear-gradient(45deg, transparent 75%, #444 75%),
      linear-gradient(-45deg, transparent 75%, #444 75%);
    background-size: 16px 16px;
    background-position: 0 0, 0 8px, 8px -8px, -8px 0px;
  }
  .small { font-size: 12px; color: var(--muted); }
  .divider { height:1px; background: rgba(255,255,255,0.06); margin: 10px 0; }
</style>
</head>
<body>
<div class="wrap">
  <h1>ドット絵コンバーター</h1>
  <div class="panel">
    <div id="drop" class="drop">
      <div>ここに画像をドラッグ＆ドロップ</div>
      <div class="small">PNG / JPG / WebP</div>
      <div style="margin-top:10px;">
        <label for="file"><button>ファイルを選択</button></label>
        <input id="file" type="file" accept="image/png,image/jpeg,image/webp" />
      </div>
    </div>
  </div>

  <div class="grid" style="margin-top:16px;">
    <div class="panel">
      <div class="row">
        <strong>元画像</strong>
      </div>
      <div class="canvas-wrap checker" style="margin-top:8px;">
        <canvas id="srcCanvas" width="320" height="240"></canvas>
      </div>
      <div class="divider"></div>
      <div class="row">
        <label>背景色</label>
        <input id="bgColor" type="color" value="#ffffff" />
        <button id="pickBtn" class="secondary">スポイト</button>
      </div>
      <div class="row" style="margin-top:8px;">
        <label>許容差</label>
        <input id="tolerance" type="range" min="0" max="100" value="30" />
        <span id="tolVal">30</span>
      </div>
      <div class="row" style="margin-top:8px;">
        <button id="removeBg">背景を透過</button>
        <button id="undo" class="secondary">元に戻す</button>
      </div>
    </div>

    <div class="panel">
      <div class="row">
        <strong>ドット絵プレビュー</strong>
      </div>
      <div class="canvas-wrap checker" style="margin-top:8px;">
        <canvas id="dstCanvas" width="320" height="240"></canvas>
      </div>
      <div class="divider"></div>
      <div class="row">
        <label>ドット絵サイズ</label>
        <select id="sizeSel">
          <option value="16">16x16</option>
          <option value="32" selected>32x32</option>
          <option value="48">48x48</option>
          <option value="64">64x64</option>
          <option value="96">96x96</option>
          <option value="128">128x128</option>
          <option value="custom">カスタム</option>
        </select>
        <input id="customSize" type="number" min="8" max="512" value="32" style="width:80px;" />
      </div>
      <div class="row" style="margin-top:8px;">
        <label>色数制限</label>
        <select id="colors">
          <option value="0">無制限</option>
          <option value="4">4</option>
          <option value="8">8</option>
          <option value="16">16</option>
          <option value="32">32</option>
          <option value="64">64</option>
          <option value="256">256</option>
        </select>
        <label style="min-width:70px;">ディザー</label>
        <select id="dither">
          <option value="none">なし</option>
          <option value="ordered">Ordered</option>
          <option value="fs">Floyd-Steinberg</option>
        </select>
      </div>
      <div class="row" style="margin-top:8px;">
        <label>輪郭強調</label>
        <input id="edges" type="checkbox" />
      </div>
      <div class="row" style="margin-top:8px;">
        <button id="convert">変換</button>
      </div>
      <div class="row" style="margin-top:8px;">
        <button id="download">PNGダウンロード</button>
        <button id="downloadPreview" class="secondary">プレビューダウンロード</button>
      </div>
    </div>
  </div>
</div>

<script>
(() => {
  const fileInput = document.getElementById('file');
  const drop = document.getElementById('drop');
  const srcCanvas = document.getElementById('srcCanvas');
  const dstCanvas = document.getElementById('dstCanvas');
  const sctx = srcCanvas.getContext('2d');
  const dctx = dstCanvas.getContext('2d');
  const bgColor = document.getElementById('bgColor');
  const tolerance = document.getElementById('tolerance');
  const tolVal = document.getElementById('tolVal');
  const pickBtn = document.getElementById('pickBtn');
  const removeBtn = document.getElementById('removeBg');
  const undoBtn = document.getElementById('undo');
  const sizeSel = document.getElementById('sizeSel');
  const customSize = document.getElementById('customSize');
  const colorsSel = document.getElementById('colors');
  const ditherSel = document.getElementById('dither');
  const edgesChk = document.getElementById('edges');
  const convertBtn = document.getElementById('convert');
  const downloadBtn = document.getElementById('download');
  const downloadPreviewBtn = document.getElementById('downloadPreview');

  let img = null;
  let originalImageData = null;
  let pickMode = false;
  let pixelArtCanvas = null;
  let previewCanvas = null;

  function setCanvasSizeForImage(c, w, h, maxW, maxH) {
    const scale = Math.min(maxW / w, maxH / h, 1);
    c.width = Math.max(1, Math.floor(w * scale));
    c.height = Math.max(1, Math.floor(h * scale));
  }

  function drawImageToSrc() {
    if (!img) return;
    setCanvasSizeForImage(srcCanvas, img.naturalWidth, img.naturalHeight, 480, 360);
    sctx.clearRect(0,0,srcCanvas.width, srcCanvas.height);
    sctx.imageSmoothingEnabled = true;
    sctx.drawImage(img, 0, 0, srcCanvas.width, srcCanvas.height);
    originalImageData = sctx.getImageData(0,0,srcCanvas.width, srcCanvas.height);
  }

  function handleFile(file) {
    if (!file) return;
    const reader = new FileReader();
    reader.onload = () => {
      img = new Image();
      img.onload = drawImageToSrc;
      img.src = reader.result;
    };
    reader.readAsDataURL(file);
  }

  drop.addEventListener('dragover', (e) => { e.preventDefault(); drop.classList.add('drag'); });
  drop.addEventListener('dragleave', () => drop.classList.remove('drag'));
  drop.addEventListener('drop', (e) => {
    e.preventDefault();
    drop.classList.remove('drag');
    if (e.dataTransfer.files && e.dataTransfer.files[0]) handleFile(e.dataTransfer.files[0]);
  });
  fileInput.addEventListener('change', (e) => handleFile(e.target.files[0]));

  tolerance.addEventListener('input', () => tolVal.textContent = tolerance.value);

  pickBtn.addEventListener('click', () => { pickMode = !pickMode; pickBtn.textContent = pickMode ? 'スポイト中...' : 'スポイト'; });

  srcCanvas.addEventListener('click', (e) => {
    if (!pickMode) return;
    const rect = srcCanvas.getBoundingClientRect();
    const x = Math.floor((e.clientX - rect.left) * (srcCanvas.width / rect.width));
    const y = Math.floor((e.clientY - rect.top) * (srcCanvas.height / rect.height));
    const data = sctx.getImageData(x, y, 1, 1).data;
    bgColor.value = rgbToHex(data[0], data[1], data[2]);
    pickMode = false;
    pickBtn.textContent = 'スポイト';
  });

  removeBtn.addEventListener('click', () => {
    if (!originalImageData) return;
    const tol = parseInt(tolerance.value, 10);
    const target = hexToRgb(bgColor.value);
    const imgData = sctx.getImageData(0,0,srcCanvas.width, srcCanvas.height);
    const d = imgData.data;
    for (let i=0;i<d.length;i+=4) {
      const dr = d[i] - target.r;
      const dg = d[i+1] - target.g;
      const db = d[i+2] - target.b;
      const dist = Math.sqrt(dr*dr + dg*dg + db*db);
      if (dist <= tol * 2.55) d[i+3] = 0;
    }
    sctx.putImageData(imgData, 0, 0);
  });

  undoBtn.addEventListener('click', () => {
    if (!originalImageData) return;
    sctx.putImageData(originalImageData, 0, 0);
  });

  sizeSel.addEventListener('change', () => {
    if (sizeSel.value === 'custom') customSize.disabled = false;
    else { customSize.disabled = true; customSize.value = sizeSel.value; }
  });
  customSize.disabled = true;

  function getTargetSize() {
    const v = sizeSel.value === 'custom' ? parseInt(customSize.value,10) : parseInt(sizeSel.value,10);
    return Math.max(8, Math.min(512, v || 32));
  }

  function getImageDataFromCanvas(canvas) {
    const ctx = canvas.getContext('2d');
    return ctx.getImageData(0,0,canvas.width, canvas.height);
  }

  function setImageDataToCanvas(canvas, imgData) {
    const ctx = canvas.getContext('2d');
    ctx.putImageData(imgData, 0, 0);
  }

  function quantize(imgData, maxColors) {
    if (maxColors <= 0) return imgData;
    const d = imgData.data;
    const map = new Map();
    for (let i=0;i<d.length;i+=4) {
      const a = d[i+3];
      if (a === 0) continue;
      const key = (d[i] << 16) | (d[i+1] << 8) | d[i+2];
      map.set(key, (map.get(key) || 0) + 1);
    }
    const palette = [...map.entries()]
      .sort((a,b)=>b[1]-a[1])
      .slice(0, maxColors)
      .map(e => ({r:(e[0]>>16)&255, g:(e[0]>>8)&255, b:e[0]&255}));
    if (palette.length === 0) return imgData;
    for (let i=0;i<d.length;i+=4) {
      const a = d[i+3];
      if (a === 0) continue;
      let best = 0, bestDist = 1e9;
      for (let p=0;p<palette.length;p++) {
        const pr = palette[p].r - d[i];
        const pg = palette[p].g - d[i+1];
        const pb = palette[p].b - d[i+2];
        const dist = pr*pr + pg*pg + pb*pb;
        if (dist < bestDist) { bestDist = dist; best = p; }
      }
      const c = palette[best];
      d[i] = c.r; d[i+1] = c.g; d[i+2] = c.b;
    }
    return imgData;
  }

  function orderedDither(imgData) {
    const d = imgData.data;
    const m = [
      [ 0,  8,  2, 10],
      [12,  4, 14,  6],
      [ 3, 11,  1,  9],
      [15,  7, 13,  5]
    ];
    for (let y=0;y<imgData.height;y++) {
      for (let x=0;x<imgData.width;x++) {
        const i = (y*imgData.width + x)*4;
        if (d[i+3] === 0) continue;
        const t = m[y%4][x%4];
        d[i] = clamp(d[i] + t - 8);
        d[i+1] = clamp(d[i+1] + t - 8);
        d[i+2] = clamp(d[i+2] + t - 8);
      }
    }
  }

  function fsDither(imgData) {
    const d = imgData.data;
    const w = imgData.width;
    const h = imgData.height;
    for (let y=0;y<h;y++) {
      for (let x=0;x<w;x++) {
        const i = (y*w + x)*4;
        if (d[i+3] === 0) continue;
        const old = [d[i], d[i+1], d[i+2]];
        const newc = old.map(v => Math.round(v/16)*16);
        d[i]=newc[0]; d[i+1]=newc[1]; d[i+2]=newc[2];
        const err = [old[0]-newc[0], old[1]-newc[1], old[2]-newc[2]];
        diffuse(x+1,y, err, 7/16); diffuse(x-1,y+1, err, 3/16); diffuse(x,y+1, err, 5/16); diffuse(x+1,y+1, err, 1/16);
      }
    }
    function diffuse(x,y,err,fac){
      if (x<0||y<0||x>=w||y>=h) return;
      const i=(y*w+x)*4; if (d[i+3]===0) return;
      d[i]=clamp(d[i]+err[0]*fac);
      d[i+1]=clamp(d[i+1]+err[1]*fac);
      d[i+2]=clamp(d[i+2]+err[2]*fac);
    }
  }

  function edgeEnhance(imgData) {
    const d = imgData.data;
    const w = imgData.width;
    const h = imgData.height;
    const out = new Uint8ClampedArray(d.length);
    const k = [-1,-1,-1,-1,8,-1,-1,-1,-1];
    for (let y=1;y<h-1;y++) {
      for (let x=1;x<w-1;x++) {
        let r=0,g=0,b=0; let ki=0;
        for (let j=-1;j<=1;j++) for (let i=-1;i<=1;i++) {
          const idx=((y+j)*w+(x+i))*4;
          r += d[idx]*k[ki]; g += d[idx+1]*k[ki]; b += d[idx+2]*k[ki]; ki++;
        }
        const o=((y*w+x)*4);
        out[o]=clamp(d[o]+r*0.15); out[o+1]=clamp(d[o+1]+g*0.15); out[o+2]=clamp(d[o+2]+b*0.15); out[o+3]=d[o+3];
      }
    }
    imgData.data.set(out);
    return imgData;
  }

  function convert() {
    if (!img) return;
    const target = getTargetSize();
    const temp = document.createElement('canvas');
    temp.width = target; temp.height = target;
    const tctx = temp.getContext('2d');
    tctx.imageSmoothingEnabled = false;
    tctx.clearRect(0,0,target,target);
    tctx.drawImage(srcCanvas, 0, 0, target, target);

    let imgData = tctx.getImageData(0,0,target,target);
    const ditherMode = ditherSel.value;
    const maxColors = parseInt(colorsSel.value,10) || 0;
    if (ditherMode === 'ordered') orderedDither(imgData);
    if (ditherMode === 'fs') fsDither(imgData);
    imgData = quantize(imgData, maxColors);
    if (edgesChk.checked) imgData = edgeEnhance(imgData);
    tctx.putImageData(imgData, 0, 0);

    pixelArtCanvas = temp;

    const scale = target <= 32 ? 8 : 4;
    previewCanvas = document.createElement('canvas');
    previewCanvas.width = target * scale;
    previewCanvas.height = target * scale;
    const pctx = previewCanvas.getContext('2d');
    pctx.imageSmoothingEnabled = false;
    pctx.drawImage(pixelArtCanvas, 0, 0, previewCanvas.width, previewCanvas.height);

    dstCanvas.width = previewCanvas.width;
    dstCanvas.height = previewCanvas.height;
    dctx.imageSmoothingEnabled = false;
    dctx.clearRect(0,0,dstCanvas.width, dstCanvas.height);
    dctx.drawImage(previewCanvas, 0, 0);
  }

  convertBtn.addEventListener('click', convert);

  downloadBtn.addEventListener('click', () => {
    if (!pixelArtCanvas) return;
    const size = getTargetSize();
    const a = document.createElement('a');
    a.download = `pixel_art_${size}.png`;
    a.href = pixelArtCanvas.toDataURL('image/png');
    a.click();
  });

  downloadPreviewBtn.addEventListener('click', () => {
    if (!previewCanvas) return;
    const size = getTargetSize();
    const a = document.createElement('a');
    a.download = `pixel_art_${size}_preview.png`;
    a.href = previewCanvas.toDataURL('image/png');
    a.click();
  });

  function rgbToHex(r,g,b){
    return '#' + [r,g,b].map(v=>v.toString(16).padStart(2,'0')).join('');
  }
  function hexToRgb(hex){
    const h = hex.replace('#','');
    return { r: parseInt(h.slice(0,2),16), g: parseInt(h.slice(2,4),16), b: parseInt(h.slice(4,6),16) };
  }
  function clamp(v){ return Math.max(0, Math.min(255, Math.round(v))); }
})();
</script>
</body>
</html>
