<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>mipurin smoke test</title>
  <style>
    body { font-family: monospace; background:#111; color:#eee; padding:16px; }
    .pass { color:#7CFC00; }
    .fail { color:#ff6b6b; }
    li { margin: 6px 0; }
  </style>
</head>
<body>
  <h1>Smoke Test</h1>
  <ul id="results"></ul>

  <script src="../js/config.js"></script>
  <script src="../js/lang.js"></script>
  <script src="../js/balance.js"></script>
  <script src="../js/save.js"></script>
  <script src="../js/inventory.js"></script>
  <script src="../js/npc.js"></script>
  <script src="../js/collection.js"></script>
  <script src="../js/dungeon.js"></script>
  <script src="../js/shop.js"></script>
  <script src="../js/analytics.js"></script>
  <script src="../js/audio.js"></script>
  <script src="../js/tileEngine.js"></script>
  <script src="../js/sprites.js"></script>
  <script src="../js/map.js"></script>
  <script src="../js/battle.js"></script>
  <script src="../js/boss.js"></script>
  <script src="../js/engine.js"></script>

  <script>
    const results = document.getElementById('results');
    function addResult(name, ok, detail='') {
      const li = document.createElement('li');
      li.className = ok ? 'pass' : 'fail';
      li.textContent = `${ok ? 'PASS' : 'FAIL'}: ${name}${detail ? ` - ${detail}` : ''}`;
      results.appendChild(li);
    }

    async function checkFetch(url) {
      try {
        const res = await fetch(url, { method: 'HEAD' });
        return res.ok;
      } catch (_) {
        return false;
      }
    }

    (async () => {
      const globals = [
        ['CONFIG', () => typeof CONFIG !== 'undefined'],
        ['Engine', () => typeof Engine !== 'undefined'],
        ['MapManager', () => typeof MapManager !== 'undefined'],
        ['NpcManager', () => typeof NpcManager !== 'undefined'],
        ['EnemyManager', () => typeof EnemyManager !== 'undefined'],
        ['PlayerController', () => typeof PlayerController !== 'undefined'],
        ['Audio', () => typeof Audio !== 'undefined'],
        ['Inventory', () => typeof Inventory !== 'undefined'],
        ['Lang', () => typeof Lang !== 'undefined']
      ];
      const missing = globals.filter(([, fn]) => !fn()).map(([name]) => name);
      addResult('Global objects exist', missing.length === 0, missing.join(', '));

      const mapNames = ['village','forest_south','forest_north','cave','flower_field'];
      let mapOk = true;
      for (const m of mapNames) {
        if (!MapManager.loadMap(m)) mapOk = false;
      }
      addResult('All required maps load', mapOk);

      await Lang.load('ja');
      const talk = NpcManager.getTalk('hatch', { killCount:0, needleUseCount:0, quest_started:false }, Inventory);
      addResult('NPC talk data retrievable', !!(talk && talk.lines));

      const enemyTypes = ['poison_mushroom','green_slime','spider','bat','ice_worm','dark_flower','shadow_bee'];
      const warn = console.warn;
      const warns = [];
      console.warn = (...args) => warns.push(args.join(' '));
      EnemyManager.clear();
      EnemyManager.spawnFromMap(enemyTypes.map((t, i) => ({ type:t, x:1+i, y:1 })));
      console.warn = warn;
      const unknown = warns.filter(w => w.includes('Unknown enemy'));
      addResult('Enemy templates exist', unknown.length === 0, unknown.join(' | '));

      const seFiles = [
        'attack.mp3','needle.mp3','hit.mp3','player_hurt.mp3','enemy_die.mp3','item_get.mp3','dialog_open.mp3','dialog_close.mp3','menu_move.mp3','menu_select.mp3','save.mp3','level_up.mp3','boss_appear.mp3','game_over.mp3','door_open.mp3'
      ];
      const seChecks = await Promise.all(seFiles.map(f => checkFetch(`../assets/se/${f}`)));
      addResult('SE files return HTTP 200', seChecks.every(Boolean), seFiles.filter((_,i)=>!seChecks[i]).join(', '));

      const prologueFiles = Array.from({length:10}, (_,i)=>`prologue_${String(i+1).padStart(2,'0')}.webp`);
      const prologueChecks = await Promise.all(prologueFiles.map(f => checkFetch(`../assets/prologue/${f}`)));
      addResult('Prologue images exist', prologueChecks.every(Boolean), prologueFiles.filter((_,i)=>!prologueChecks[i]).join(', '));

      const boss1 = BossManager.spawn('mushroom_king');
      addResult('BossManager.spawn mushroom_king hp=30', !!boss1 && boss1.hp === 30, boss1 ? `hp=${boss1.hp}` : 'no boss');
      const boss2 = BossManager.spawn('ice_beetle');
      addResult('BossManager.spawn ice_beetle hp=50', !!boss2 && boss2.hp === 50, boss2 ? `hp=${boss2.hp}` : 'no boss');
      const boss3 = BossManager.spawn('dark_queen');
      addResult('BossManager.spawn dark_queen hp=80', !!boss3 && boss3.hp === 80, boss3 ? `hp=${boss3.hp}` : 'no boss');

      const bossCheck = BossManager.spawn('mushroom_king');
      const beforeHp = bossCheck ? bossCheck.hp : 0;
      const box = bossCheck ? { x: bossCheck.x, y: bossCheck.y, w: 10, h: 10 } : null;
      const hit = box ? BossManager.checkHit(box, 1) : false;
      const afterHp = bossCheck ? bossCheck.hp : beforeHp;
      addResult('BossManager.checkHit reduces HP', hit && afterHp < beforeHp, `before=${beforeHp} after=${afterHp}`);

      addResult('Ending type C when killCount=0', NpcManager.getEndingType({ killCount:0 }, null) === 'ending_c');
      addResult('Ending type A when needle finish', NpcManager.getEndingType({ killCount:5 }, 'needle_finish') === 'ending_a');
      addResult('Ending type B otherwise', NpcManager.getEndingType({ killCount:5 }, 'attack_finish') === 'ending_b');

      const requiredMaps = ['village','forest_south','forest_north','cave','flower_field'];
      const loadedMaps = requiredMaps.filter(m => !!MapManager.loadMap(m)).length;
      const invalidMaps = ['boss','dungeon','unknown'].every(m => !MapManager.loadMap(m));
      addResult('MapManager has exactly 5 maps', loadedMaps === 5 && invalidMaps, `loaded=${loadedMaps}`);

      addResult('MapManager.TILE.SEAL_WALL exists', typeof MapManager.TILE.SEAL_WALL === 'number');

      const allEnemies = ['poison_mushroom','green_slime','spider','bomb_mushroom','dark_slime','bat','ice_worm','dark_flower','shadow_bee'];
      const enemyKeys = Object.keys(Balance.ENEMIES || {});
      const enemiesOk = allEnemies.every(e => enemyKeys.includes(e)) && enemyKeys.length === 9;
      addResult('Balance.ENEMIES has all 9 types', enemiesOk, enemyKeys.join(', '));

      const langKeys = [
        'title','press_start','menu_story','menu_dungeon','menu_collection','menu_settings','menu_credits',
        'mipurin_home','npc_hatch_first','npc_hatch_pacifist','npc_hatch_normal','npc_hatch_violent',
        'npc_miel_normal','npc_miel_hint','npc_miel_worried','npc_marche','npc_marche_closed','npc_bee',
        'npc_pore_normal','npc_navi_first','npc_navi_repeat','save_point_text','area_locked','chest_empty',
        'sign_village','sign_forest_south','sign_forest_north','sign_cave','sign_flower_field',
        'game_over','continue_prompt','credits_thanks',
        'ending_a','ending_a_title','ending_b','ending_b_title','ending_c','ending_c_title',
        ...Array.from({length:10}, (_,i)=>`prologue_${String(i+1).padStart(2,'0')}`)
      ];
      const missingLang = langKeys.filter(k => {
        const v = Lang.t(k);
        return !v || v === k;
      });
      addResult('All Lang.t keys in game/npc are defined', missingLang.length === 0, missingLang.join(', '));

      addResult('BossManager global exists', typeof BossManager !== 'undefined');
      const bossA = BossManager.spawn('mushroom_king');
      addResult('BossManager.spawn mushroom_king returns hp=30', !!bossA && bossA.hp === 30, bossA ? `hp=${bossA.hp}` : 'no boss');
      const bossB = BossManager.spawn('ice_beetle');
      addResult('BossManager.spawn ice_beetle returns hp=50', !!bossB && bossB.hp === 50, bossB ? `hp=${bossB.hp}` : 'no boss');
      const bossC = BossManager.spawn('dark_queen');
      addResult('BossManager.spawn dark_queen returns hp=80', !!bossC && bossC.hp === 80, bossC ? `hp=${bossC.hp}` : 'no boss');

      addResult('NpcManager.getEndingType killCount=0 => ending_c', NpcManager.getEndingType({ killCount:0 }) === 'ending_c');
      addResult('NpcManager.getEndingType needle_finish => ending_a', NpcManager.getEndingType({ lastAction:'needle_finish', killCount:5 }) === 'ending_a');
      addResult('NpcManager.getEndingType killCount=5 => ending_b', NpcManager.getEndingType({ killCount:5 }) === 'ending_b');

      const mapCollection = MapManager._maps || MapManager.maps || {};
      addResult('MapManager has 5 maps', Object.keys(mapCollection).length === 5, `count=${Object.keys(mapCollection).length}`);
      addResult('MapManager.TILE.SEAL_WALL is number', typeof MapManager.TILE.SEAL_WALL === 'number');

      const enemyList = ['poison_mushroom','green_slime','spider','bat','ice_worm','dark_flower','shadow_bee','bomb_mushroom','dark_slime'];
      const enemySet = Object.keys(Balance.ENEMIES || {});
      const enemyOk = enemyList.every(e => enemySet.includes(e)) && enemySet.length === 9;
      addResult('Balance.ENEMIES has all 9 types', enemyOk, enemySet.join(', '));

      const requiredLang = [
        'prologue_01','ending_a_title','ending_a_text','npc_hatch_first','boss_mushroom_king_intro',
        'item_piece_a_name','shop_title','save_success','dungeon_enter','collection_title'
      ];
      const missingRequired = requiredLang.filter(k => {
        const v = Lang.t(k);
        return !v || v === k;
      });
      addResult('Lang.t required keys non-empty', missingRequired.length === 0, missingRequired.join(', '));
    })();
  </script>
</body>
</html>
